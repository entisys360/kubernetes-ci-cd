parts:

  - name: Part 1
    intro: In this part we will setup a local cluster with minikube, deploy a public image from dockerhub, customize that image, and then finally deploy it inside our local cluster.
    steps:

      - cap: Start up the Kubernetes cluster with Minikube, giving it some extra resources.
        com: minikube start --memory 4000 --cpus 2 --kubernetes-version v1.11.0

      - cap: Enable the Minikube add-ons Heapster and Ingress.
        com: minikube addons enable heapster; minikube addons enable ingress

      - cap: View the Minikube Dashboard, a web UI for managing deployments.
        com: minikube service kubernetes-dashboard --namespace kube-system

      - cap: Deploy the public nginx image from DockerHub into a pod. Nginx is an open source web server that will automatically download from Docker Hub if it’s not available locally.
        com: kubectl run nginx --image nginx --port 80

      - cap: Create a K8s Service for the deployment. This will expose the nginx pod so you can access it with a web browser.
        com: kubectl expose deployment nginx --type NodePort --port 80

      - cap: Launch a web browser to test the service. The nginx welcome page displays, which means the service is up and running.
        com: minikube service nginx
        
      - cap: Delete the nginx deployment and service you created. 
        com: kubectl delete service nginx; kubectl delete deployment nginx

      - cap: Set up the cluster registry by applying a .yaml manifest file.
        com: kubectl apply -f manifests/registry.yaml

      - cap: Wait for the registry to finish deploying. Note that this may take several minutes.
        com: kubectl rollout status deployments/registry

      - cap: View the registry user interface in a web browser.
        com: minikube service registry-ui

      - cap: Let’s make a change to an HTML file in the cloned project. Open the /applications/hello-kenzan/index.html file in your favorite text editor (for example, you can use nano by running the command 'nano applications/hello-kenzan/index.html' in a separate terminal). Change some text inside one of the <p> tags. For example, change “Hello from Kenzan!” to “Hello from Me!”. Save the file. 
        com: echo ''

      - cap: Now let’s build an image, giving it a special name that points to our local cluster registry.
        com: docker build -t alex301427/hello-kenzan -f applications/hello-kenzan/Dockerfile applications/hello-kenzan

      - cap: With our proxy container up and running, we can now push our hello-kenzan image to the docker.io repository.
        com: docker push alex301427/hello-kenzan:latest

      - cap: With the image in our docker.io registry, the last thing to do is apply the manifest to create and deploy the hello-kenzan pod based on the image.
        com: kubectl apply -f applications/hello-kenzan/k8s/manual-deployment.yaml

      - cap: Launch a web browser and view the service.
        com: minikube service hello-kenzan

      - cap: Delete the hello-kenzan deployment and service you created. 
        com: kubectl delete service hello-kenzan; kubectl delete deployment hello-kenzan
parts:

  - name: Part 2
    intro: In this part we will Setup Jenkins, and setup an automated pipeline to build, push and deploy our custom appliction.
    steps:

      - cap: Let's build the Jenkins Docker image we'll use in our Kubernetes cluster. 
        com: docker build -t alex301427/jenkins:latest -f applications/jenkins/Dockerfile applications/jenkins

      - cap: We can now push our Jenkins image to the docker.io repository.
        com: docker push alex301427/jenkins:latest

      - cap: Deploy Jenkins, which we’ll use to create our automated CI/CD pipeline. It will take the pod a minute or two to roll out.
        com: kubectl apply -f manifests/jenkins.yaml; kubectl rollout status deployment/jenkins

      - cap: Open the Jenkins UI in a web browser. 
        com: minikube service jenkins

      - cap: Display the Jenkins admin password with the following command, and right-click to copy it. ALSO IMPORTANT!  You'll only need to do the password and pipeline setup once, as the container user persistent storage. IMPORTANT: BE CAREFUL NOT TO PRESS CTRL-C TO COPY THE PASSWORD AS THIS WILL STOP THE SCRIPT
        com: kubectl exec -it `kubectl get pods --selector=app=jenkins --output=jsonpath={.items..metadata.name}` cat /var/jenkins_home/secrets/initialAdminPassword

      - cap: Switch back to the Jenkins UI. Paste the Jenkins admin password in the box and click Continue. Click Install suggested plugins. Plugins have actually been pre-downloaded during the Jenkins image build, so this step should finish fairly quickly. 
        com: echo '' 

      - cap: Create an admin user and credentials, and click Save and Continue. (Make sure to remember these credentials as you will need them for repeated logins.) On the Instance Configuration page, click Save and Finish. On the next page, click Restart (if it appears to hang for some time on restarting, you may have to refresh the browser window). Login to Jenkins.
        com: echo ''

      - cap: Before we create a pipeline, we first need to provision the Kubernetes Continuous Deploy plugin with a kubeconfig file that will allow access to our Kubernetes cluster. In Jenkins on the left, click on Credentials, select the Jenkins store, then Global credentials (unrestricted), and Add Credentials on the left menu.
        com: echo ''

      - cap: The following values must be entered precisely as indicated: for the Kind field select the option `Kubernetes configuration (kubeconfig)`, set the ID as `kenzan_kubeconfig`, set Kubeconfig to `From a file on the Jenkins master`, and specify the the file path as `/var/jenkins_home/.kube/config`. Click the OK button.
        com: echo ''

      - cap: We now want to create a new pipeline for use with our Hello-Kenzan app. Back on Jenkins home, on the left, click New Item. Enter the item name as "Hello-Kenzan Pipeline", select Pipeline, and click OK.
        com: echo ''

      - cap: Under the Pipeline section at the bottom, change the Definition to be "Pipeline script from SCM". 
        com: echo ''

      - cap: Change the SCM to Git. Change the Repository URL to be the URL of your forked Git repository, such as https://github.com/[GIT USERNAME]/kubernetes-ci-cd. Click Save. On the left, click Build Now to run the new pipeline. 
        com: echo ''

      - cap: After all pipeline stages are colored green as complete, view the Hello-Kenzan application.
        com: minikube service hello-kenzan

      - cap: Push a change to your fork. Run the job again. View the changes.
        com: minikube service hello-kenzan
